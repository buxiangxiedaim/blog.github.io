{"meta":{"title":"开塞露加冰的博客","subtitle":"","description":"","author":"张尹","url":"https://kaisailu-with-ice.gitee.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"图片预加载","slug":"图片预加载","date":"2022-12-05T07:58:25.803Z","updated":"2022-12-05T08:05:55.759Z","comments":true,"path":"2022/12/05/图片预加载/","link":"","permalink":"https://kaisailu-with-ice.gitee.io/blog/2022/12/05/%E5%9B%BE%E7%89%87%E9%A2%84%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"在制作个人网页时遇到了一个需求。由于网站内静态资源图片比较多，若按照普通加载方式，当网速不是非常快时会出现已经进入网站，但图片还在加载的情况 客户端主要代码客户端最基础的两个功能：使用socket.emit()发送命令，socket.on()接收数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, { useState, useEffect, useRef } from 'react';import io from 'socket.io-client';const socket = io(window._CONFIG[\"socketUrl\"]);const Home = () =&gt; { const [userInfo, setUserInfo] = useState({city:'',ip:''}) const [inputVal, setInputVal] = useState('') //input输入值 const [msgList, setMsgList ] = useState([]) //消息列表 useEffect(() =&gt; { // console.log(inputRef.current); socket.on('info', (data) =&gt; { //单条信息事件 setMsgList([...msgList,data]) }); socket.on('response_msg', (data) =&gt; { //历史信息事件 setMsgList([...data]) }); }, [msgList]); // 获取历史消息 const getHistoryMsg = () =&gt; { socket.emit('getHistory', '点击获取历史记录') } // 提交消息 const submit = useThrottle(() =&gt; { const newVal = inputVal.trim() if(!newVal){ return message.info('消息不可为空') } let params = { id:new Date().getTime(), date: new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString(), message: inputVal, } socket.emit('submit', params) },1000) // 键盘事件 const inputKeyDown = (e) =&gt; { // 当按下回车键 if(e.keyCode === 13){ e.preventDefault(); submit() } }};export default Home; 后台主要代码后台当客户端连接成功后，对两个事件进行监听，并作出相应操作。 12345678910111213141516171819202122232425262728293031323334353637383940const app = require('express')();const http = require('http').Server(app);//这里必须绑定在http实例上而不是app上const io = require('socket.io')(http, { cors: true }); //1.解决跨域const mysql = require('mysql');const db = mysql.createPool({ host : 'localhost', user : 'root', password : '123456', database : 'demo'});io.on('connection', function (socket) { // 当客户端提交消息 socket.on('submit', function (data){ // 将收到的消息发给客户端 io.emit('info', data) // 将收到的消息插入数据库 const { date, message } = data db.query('INSERT INTO chats (date, message) VALUES (?, ?)',[date, message], (err, res) =&gt; { if (err) throw err; console.log('数据插入成功！'); }) }); // 当客户端请求历史消息 socket.on('getHistory', function (data){ db.query('SELECT * FROM chats', function (error, results, fields) { if (error) throw error; let result = JSON.parse(JSON.stringify(results)) // 将查询到的消息发送给客户端 socket.emit('response_msg',result) }); })});http.listen(9000, () =&gt; { console.log('监听端口:9000');}); 客户端和后端依赖不同客户端使用的是socket.io-client，而后台使用的是socket.io 12npm install socket.io-client //前台依赖npm install socket.io //后台依赖 同步在线人数功能代码同步在线人数主要的实现思路是，后台声明一个变量num，当连接成功时+1，断开连接时-1，并将变量发送给客户端 1234567891011121314let num = 0io.on('connection', function (socket) { num++ console.log('已连接'); io.emit('num_change', num) // 连接已断开 socket.on('disconnect', () =&gt; { num-- io.emit('num_change', num) console.log('连接已断开...') });}); 官方文档中是有socket.on(‘disconnect’, () =&gt; {})事件监听的，但是我这里使用始终不生效。 获取用户ip属地功能代码主要使用http://pv.sohu.com/cityjson?ie=utf-8 这个api 1234567891011121314151617181920212223// 首先在proxy中配置代理'/apiSohu': { target: 'http://pv.sohu.com', // localhost=&gt;target changeOrigin: true, pathRewrite: { '^/apiSohu/': '/' }}// 其次使用axios进行请求userCity: `${apiSohu}/cityjson?ie=utf-8`async getUserInfo(data){ const response = await this.$http({ url : userCity, method: \"get\", data, }) return this.$handleResponse(response)}useEffect(() =&gt; { getUserInfo()},[]) 消息颜色功能代码取色器功能相对后台比较简单，只是增加了一个color字段而已。重点在于HTML5自带取色器，之前确实不清楚。 1234567const [color, setColor] = useState('')const colorChange = e =&gt; { setColor(e.target.value)}&lt;input type=\"color\" value={color} onChange={colorChange}/&gt;","categories":[{"name":"my_project\n- 文章分类","slug":"my-project-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/my-project-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/JavaScript/"}]},{"title":"Socket.IO实现聊天室","slug":"readme","date":"2022-11-11T01:28:38.828Z","updated":"2022-11-11T01:43:07.810Z","comments":true,"path":"2022/11/11/readme/","link":"","permalink":"https://kaisailu-with-ice.gitee.io/blog/2022/11/11/readme/","excerpt":"","text":"学习Socket.IO的过程中制作了一个实时聊天室demo，本文记录一下主要实现代码和主要功能遇到的困难 客户端主要代码客户端最基础的两个功能：使用socket.emit()发送命令，socket.on()接收数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, { useState, useEffect, useRef } from 'react';import io from 'socket.io-client';const socket = io(window._CONFIG[\"socketUrl\"]);const Home = () =&gt; { const [userInfo, setUserInfo] = useState({city:'',ip:''}) const [inputVal, setInputVal] = useState('') //input输入值 const [msgList, setMsgList ] = useState([]) //消息列表 useEffect(() =&gt; { // console.log(inputRef.current); socket.on('info', (data) =&gt; { //单条信息事件 setMsgList([...msgList,data]) }); socket.on('response_msg', (data) =&gt; { //历史信息事件 setMsgList([...data]) }); }, [msgList]); // 获取历史消息 const getHistoryMsg = () =&gt; { socket.emit('getHistory', '点击获取历史记录') } // 提交消息 const submit = useThrottle(() =&gt; { const newVal = inputVal.trim() if(!newVal){ return message.info('消息不可为空') } let params = { id:new Date().getTime(), date: new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString(), message: inputVal, } socket.emit('submit', params) },1000) // 键盘事件 const inputKeyDown = (e) =&gt; { // 当按下回车键 if(e.keyCode === 13){ e.preventDefault(); submit() } }};export default Home; 后台主要代码后台当客户端连接成功后，对两个事件进行监听，并作出相应操作。 12345678910111213141516171819202122232425262728293031323334353637383940const app = require('express')();const http = require('http').Server(app);//这里必须绑定在http实例上而不是app上const io = require('socket.io')(http, { cors: true }); //1.解决跨域const mysql = require('mysql');const db = mysql.createPool({ host : 'localhost', user : 'root', password : '123456', database : 'demo'});io.on('connection', function (socket) { // 当客户端提交消息 socket.on('submit', function (data){ // 将收到的消息发给客户端 io.emit('info', data) // 将收到的消息插入数据库 const { date, message } = data db.query('INSERT INTO chats (date, message) VALUES (?, ?)',[date, message], (err, res) =&gt; { if (err) throw err; console.log('数据插入成功！'); }) }); // 当客户端请求历史消息 socket.on('getHistory', function (data){ db.query('SELECT * FROM chats', function (error, results, fields) { if (error) throw error; let result = JSON.parse(JSON.stringify(results)) // 将查询到的消息发送给客户端 socket.emit('response_msg',result) }); })});http.listen(9000, () =&gt; { console.log('监听端口:9000');}); 客户端和后端依赖不同客户端使用的是socket.io-client，而后台使用的是socket.io 12npm install socket.io-client //前台依赖npm install socket.io //后台依赖 同步在线人数功能代码同步在线人数主要的实现思路是，后台声明一个变量num，当连接成功时+1，断开连接时-1，并将变量发送给客户端 1234567891011121314let num = 0io.on('connection', function (socket) { num++ console.log('已连接'); io.emit('num_change', num) // 连接已断开 socket.on('disconnect', () =&gt; { num-- io.emit('num_change', num) console.log('连接已断开...') });}); 官方文档中是有socket.on(‘disconnect’, () =&gt; {})事件监听的，但是我这里使用始终不生效。 获取用户ip属地功能代码主要使用http://pv.sohu.com/cityjson?ie=utf-8 这个api 1234567891011121314151617181920212223// 首先在proxy中配置代理'/apiSohu': { target: 'http://pv.sohu.com', // localhost=&gt;target changeOrigin: true, pathRewrite: { '^/apiSohu/': '/' }}// 其次使用axios进行请求userCity: `${apiSohu}/cityjson?ie=utf-8`async getUserInfo(data){ const response = await this.$http({ url : userCity, method: \"get\", data, }) return this.$handleResponse(response)}useEffect(() =&gt; { getUserInfo()},[]) 消息颜色功能代码取色器功能相对后台比较简单，只是增加了一个color字段而已。重点在于HTML5自带取色器，之前确实不清楚。 1234567const [color, setColor] = useState('')const colorChange = e =&gt; { setColor(e.target.value)}&lt;input type=\"color\" value={color} onChange={colorChange}/&gt;","categories":[{"name":"my_project","slug":"my-project","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/my-project/"}],"tags":[{"name":"Socket.IO","slug":"Socket-IO","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/Socket-IO/"}]},{"title":"分页上传","slug":"分页上传","date":"2022-11-08T06:34:00.384Z","updated":"2022-11-08T08:17:56.038Z","comments":true,"path":"2022/11/08/分页上传/","link":"","permalink":"https://kaisailu-with-ice.gitee.io/blog/2022/11/08/%E5%88%86%E9%A1%B5%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"功能目的：1.对文件进行切片上传，使得每个接口响应时间缩短；2.控制请求并发量，避免请求过多导致页面崩溃；3.当部分请求失败，将失败的部分重新上传。 一.切片上传：1.使用FileReader接口提供的readAsArrayBuffer()读取file中的内容；2.使用SparkMD5存放读取出的ArrayBuffer对象；3.使用文件file对象的slice()方法进行切片。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import React from 'react';import SparkMD5 from 'spark-md5';import axios from 'axios';const Home = () =&gt; { axios.defaults.baseURL = 'http://20.46.4.225:8080/study/common' // 请求基准地址 const CHUNK_SIZE = 1024 * 10; //10KB const fileChunkList = [] //存放文件切片 let file = {} //文件 let hash = \"\" //文件hash const change = e =&gt; { file = e.target.files[0] } const upload = () =&gt; { // 1.计算文件hash值 calculateFileHash(file) // 2.将文件名、hash、文件大小调用接口 .then(async res =&gt; { hash = res const params = { filename: file.name, hash: res, length: file.size, }; return axios({ method: 'post', url: '/chunk/info', data: params }) }) .then(async res =&gt; { // 3.将文件切片 fileChunk(file) // 4.将切片后的文件遍历上传 const uploadList = fileChunkList.map( v =&gt; { const formData = new FormData(); formData.append('chunkCount', fileChunkList.length); formData.append('chunkIndex', v.chunkIndex); formData.append('chunkSize', v.chunkSize); formData.append('fileHash', hash); formData.append('path', res.path); formData.append('file', v.chunk); formData.append('everySize', CHUNK_SIZE); return axios({ method: 'post', url: '/chunk/upload', data: formData, headers: { 'Content-Type': 'multipart/form-data' } }) }) await Promise.all(uploadList) console.log('已完成'); }) }; const calculateFileHash = (file) =&gt; { return new Promise((resolve, reject) =&gt; { const fileReader = new FileReader(); const spark = new SparkMD5.ArrayBuffer(); fileReader.readAsArrayBuffer(file); fileReader.onload = (e) =&gt; { spark.append(e.target.result); resolve(spark.end()); }; }); }; const fileChunk = (file) =&gt; { let cur = 0; let index = 1; while (cur &lt; file.size) { fileChunkList.push({ chunkIndex: index, chunk: file.slice(cur, cur + CHUNK_SIZE), chunkSize: file.slice(cur, cur + CHUNK_SIZE).size }) cur += CHUNK_SIZE; index++ } } return ( &lt;div className='home-page'&gt; &lt;input type=\"file\" id=\"fileInput\" onChange={change}/&gt; &lt;button id=\"uploadBtn\" onClick={upload}&gt;上传&lt;/button&gt; &lt;/div&gt; );};export default Home; 二.控制并发：Promise.race()方法返回一个promise，当接收的某个promise状态发生改变，无论成功或失败，Promise.race()会返回这个状态。使用Promise.race()来控制并发量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const upload = () =&gt; { // 1.计算文件hash值 calculateFileHash(file) // 2.将文件名、hash、文件大小调用接口 .then(async res =&gt; { hash = res const params = { filename: file.name, hash: res, length: file.size, }; return axios({ method: 'post', url: '/chunk/info', data: params }) }) .then(async res =&gt; { // 3.将文件切片 fileChunk(file) let pond = []; //并发池 let max = 3 //最大并发量 // 4.将切片后的文件遍历上传 for (let i = 0; i &lt; fileChunkList.length; i++) { let v = fileChunkList[i] const formData = new FormData(); formData.append('chunkCount', fileChunkList.length); formData.append('chunkIndex', v.chunkIndex); formData.append('chunkSize', v.chunkSize); formData.append('fileHash', hash); formData.append('path', res.path); formData.append('file', v.chunk); formData.append('everySize', CHUNK_SIZE); let result = axios({ method: 'post', url: '/chunk/upload', data: formData, headers: { 'Content-Type': 'multipart/form-data' } }) // 5.将请求添加至并发池中 pond.push(result) result.then( res =&gt; { // 6.当请求成功返回，将其从pond中删除 let index = pond.findIndex( i =&gt; i === result) pond.splice(index, 1) }) // 7.当并发值达到设定值 if(pond.length === max){ //每当并发池跑完一个任务，就再塞入一个任务 console.log('满了满了'); await Promise.race(pond) } } console.log('已完成'); }) }; 三.断点续传：使用catch捕获失败的请求，在所有请求响应完毕后，将失败的请求重新进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const upload = () =&gt; { // 1.计算文件hash值 calculateFileHash(file) // 2.将文件名、hash、文件大小调用接口 .then(async res =&gt; { hash = res const params = { filename: file.name, hash: res, length: file.size, }; return axios({ method: 'post', url: '/chunk/info', data: params }) }) .then(async res =&gt; { // 3.将文件切片 fileChunk(file) let pond = []; //并发池 let max = 3 //最大并发量 let num = 0 //成功上传的数量 let failList = [] //失败的列表 const uploadChunkList = async (list) =&gt; { // // 4.将切片后的文件遍历 for (let i = 0; i &lt; list.length; i++) { let v = list[i]; const formData = new FormData(); formData.append('chunkCount', list.length); formData.append('chunkIndex', v.chunkIndex); formData.append('chunkSize', v.chunkSize); formData.append('fileHash', hash); formData.append('path', res.path); formData.append('file', v.chunk); formData.append('everySize', CHUNK_SIZE); let result = axios({ method: 'post', url: '/chunk/upload', data: formData, headers: { 'Content-Type': 'multipart/form-data' } }) // 5.将请求添加至并发池中 pond.push(result); result.then((res) =&gt; { // 6.当请求成功返回，将其从pond中删除 let index = pond.findIndex((i) =&gt; i === result); pond.splice(index, 1); }).catch( () =&gt; { // 7.如果请求失败，将此切片保存 failList.push(v) }).finally(() =&gt; { num++ // 8.当所有请求完成，将失败的列表再次进行处理 if(num === list.length) {uploadChunkList(failList)} }) // 当并发值达到设定值 if (pond.length === max) { //每当并发池跑完一个任务，就再塞入一个任务 console.log('满了满了'); await Promise.race(pond); } } console.log('已完成'); fileChunkList = []; }; uploadChunkList(fileChunkList) }) };","categories":[{"name":"基础业务 - 文章分类","slug":"基础业务-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/%E5%9F%BA%E7%A1%80%E4%B8%9A%E5%8A%A1-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-21T03:43:02.633Z","updated":"2022-10-25T03:44:51.746Z","comments":true,"path":"2022/10/21/hello-world/","link":"","permalink":"https://kaisailu-with-ice.gitee.io/blog/2022/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files😄 1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"xxx - 文章分类","slug":"xxx-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/xxx-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"sss","slug":"sss","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/sss/"}]},{"title":"React使用less","slug":"first-blog","date":"2022-10-21T03:43:02.631Z","updated":"2022-10-25T06:02:20.386Z","comments":true,"path":"2022/10/21/first-blog/","link":"","permalink":"https://kaisailu-with-ice.gitee.io/blog/2022/10/21/first-blog/","excerpt":"","text":"在使用 create-react-app 时发现不支持 less，需更手动更改。 1、下载 less less-loader1234// 使用npm npm install less less-loader -D // 使用 yarn yarn add less less-loader 2、配置 webpack.config.js在这里如果项目中没有 webpack.config.js 此文件的，可以执行npm run eject，如果执行报错，则执行以下命令 123git add .git commit -m \"init\"npm run eject 在 webpack.config.js 文件中是可以看到对 sass 的配置的，在 sass 配置的后面复制一份，改成 less 的配置就可以了。 123456789101112131415161718192021222324252627282930313233343536373839// style files regexesconst cssRegex = /\\.css$/;const cssModuleRegex = /\\.module\\.css$/;const sassRegex = /\\.(scss|sass)$/;const sassModuleRegex = /\\.module\\.(scss|sass)$/;//新建less配置：const lessRegex = /\\.(less|less)$/;const lessModuleRegex = /\\.module\\.(less|less)$/;//在module中找到rules下的oneOf 并在sass后添加如下配置{ test: lessRegex, exclude: lessModuleRegex, use: getStyleLoaders( { importLoaders: 3, sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment, }, 'less-loader' ), sideEffects: true,},{ test: lessModuleRegex, use: getStyleLoaders( { importLoaders: 3, sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment, modules: { getLocalIdent: getCSSModuleLocalIdent, }, }, 'less-loader' ),} 3、配置后运行报错 TypeError:this.getOptions is not a function错误原因：8.0+版本的 less-loader 的配置方法发生了变化，导致报错解决方法：安装低版本的 less-loader 1234// 使用npm npm install less-loader@5.0.0 -D // 使用 yarn yarn add less-loader@5.0.0 -D","categories":[{"name":"React - 文章分类","slug":"React-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/React-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"less","slug":"less","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/less/"}]}],"categories":[{"name":"my_project\n- 文章分类","slug":"my-project-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/my-project-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"},{"name":"my_project","slug":"my-project","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/my-project/"},{"name":"基础业务 - 文章分类","slug":"基础业务-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/%E5%9F%BA%E7%A1%80%E4%B8%9A%E5%8A%A1-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"},{"name":"xxx - 文章分类","slug":"xxx-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/xxx-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"},{"name":"React - 文章分类","slug":"React-文章分类","permalink":"https://kaisailu-with-ice.gitee.io/blog/categories/React-%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/JavaScript/"},{"name":"Socket.IO","slug":"Socket-IO","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/Socket-IO/"},{"name":"文件上传","slug":"文件上传","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"sss","slug":"sss","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/sss/"},{"name":"less","slug":"less","permalink":"https://kaisailu-with-ice.gitee.io/blog/tags/less/"}]}